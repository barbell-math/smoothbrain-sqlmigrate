// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: query.sql

package queries

import (
	"context"
)

const createSchema = `-- name: CreateSchema :exec
CREATE SCHEMA IF NOT EXISTS smoothbrain_sqlmigrate
`

func (q *Queries) CreateSchema(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createSchema)
	return err
}

const createVersioning = `-- name: CreateVersioning :exec
CREATE TABLE IF NOT EXISTS smoothbrain_sqlmigrate.versioning (
	id INT NOT NULL UNIQUE,
	ok BOOLEAN NOT NULL
)
`

func (q *Queries) CreateVersioning(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createVersioning)
	return err
}

const maxID = `-- name: MaxID :one
SELECT COALESCE(MAX(id), -1) FROM smoothbrain_sqlmigrate.versioning
`

func (q *Queries) MaxID(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRow(ctx, maxID)
	var coalesce interface{}
	err := row.Scan(&coalesce)
	return coalesce, err
}

const needToBeRun = `-- name: NeedToBeRun :many
SELECT id FROM smoothbrain_sqlmigrate.versioning WHERE ok=false ORDER BY id ASC
`

func (q *Queries) NeedToBeRun(ctx context.Context) ([]int32, error) {
	rows, err := q.db.Query(ctx, needToBeRun)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const needUpdate = `-- name: NeedUpdate :one
SELECT EXISTS (
	SELECT 1
	FROM   smoothbrain_sqlmigrate.versioning
	WHERE  ok = false
	LIMIT  1
)
`

func (q *Queries) NeedUpdate(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, needUpdate)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const setStatus = `-- name: SetStatus :exec
INSERT INTO smoothbrain_sqlmigrate.versioning (
	id, ok
) VALUES ($1, $2) ON CONFLICT(id) DO UPDATE SET ok=$2
`

type SetStatusParams struct {
	ID int32
	Ok bool
}

func (q *Queries) SetStatus(ctx context.Context, arg SetStatusParams) error {
	_, err := q.db.Exec(ctx, setStatus, arg.ID, arg.Ok)
	return err
}

const status = `-- name: Status :many
SELECT id, ok FROM smoothbrain_sqlmigrate.versioning ORDER BY id ASC
`

func (q *Queries) Status(ctx context.Context) ([]SmoothbrainSqlmigrateVersioning, error) {
	rows, err := q.db.Query(ctx, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SmoothbrainSqlmigrateVersioning
	for rows.Next() {
		var i SmoothbrainSqlmigrateVersioning
		if err := rows.Scan(&i.ID, &i.Ok); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const versioningExists = `-- name: VersioningExists :one
SELECT EXISTS (
   SELECT FROM information_schema.tables 
   WHERE  table_schema = 'smoothbrain_sqlmigrate'
   AND    table_name   = 'versioning'
)
`

func (q *Queries) VersioningExists(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, versioningExists)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
